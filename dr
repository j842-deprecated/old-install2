#!/bin/bash

# ------------------------------------------------------------------
#
#  dr : docker runner
#  manage docker containers in a simple and consistent way.
#  
#  See:
#    https://github.com/j842/dr
#
# ------------------------------------------------------------------

if [ "$EUID" -ne 0 ]; then echo "Please run as root" ; exit 1 ; fi

# Global constants.
readonly DRUSER="druser"
readonly DRGROUP="drgroup"
readonly DRETCDIR="/etc/dr"
readonly DRCFGDIR="config"
readonly DRBINDIR="bin"
readonly CFG_DIRECTORY="${DRETCDIR}/directory"
readonly CFG_IMAGENAME="${DRCFGDIR}/imagename.txt"
readonly CFG_SERVICENAME="${DRCFGDIR}/servicename.txt"
readonly REQDFILES=("install" "destroy" "backup" "restore" "help" "enter" )
readonly COPYIMAGE="j842/dr-baseimage-alpine"
readonly BACKUP_HOSTZIP="config_host.tar.7z"
readonly BACKUP_VOLZIP="config_volume_container.tar.7z"
readonly BACKUP_MAIN="backup.tar.7z"
   
# Global variables
SERVICENAME=""
DIRECTORY=""  
DIRSERVICE=""
IMAGENAME=""

#------------------------------------------------------------------------------------

# die MESSAGE 
function die {
   if [ -n "$1" ]; then
      echo "$MESSAGE" <&2
   else
      echo "Unexpected error. Exiting."<&2
   fi
   exit 1
}

#------------------------------------------------------------------------------------

# serviceline SERVICE SHORTHELP
function serviceline {
   printf "   %-15s - %-55s\n" "$1" "$2"
}

#------------------------------------------------------------------------------------

# showservices
function showservices {
   # list available services. 
   # function install here should create imagename.txt
   # the container's drinstall script should create the shorthelp.txt file
   if [ -z $DIRECTORY ]; then die "Main directory not set - can't show services." ; fi
   echo "AVAILABLE SERVICES"
   find "$DIRECTORY" -maxdepth 1 -type d | while read SERVICEPATH; do 
      if [ -e "${SERVICEPATH}/${CFG_IMAGENAME}" ]; then
         SERVICEIMAGENAME=$(<"$SERVICEPATH/${CFG_IMAGENAME}")
         serviceline "${SERVICEPATH##*/}" "$SERVICEIMAGENAME"
      fi
   done
}

#------------------------------------------------------------------------------------

# showusage
function showusage {
cat <<'EOF' >&2

NAME
   dr - docker runner
   
SYNOPSIS
   dr configure DIRECTORY
   dr clean
   dr list
   
   dr install IMAGENAME SERVICENAME   
   dr update SERVICENAME
   dr destroy SERVICENAME

   PASS=? dr backup SERVICENAME BACKUPFILE
   PASS=? dr restore SERVICENAME BACKUPFILE
   
   dr SERVICENAME
   dr SERVICENAME enter
   dr SERVICENAME COMMAND ARGS

DESCRIPTION
   Provides a standard way to manage and run containers supporting dr.
   Intended to be used both manually and via Ansible.
   See https://github.com/j842/dr
   
EXIT CODE
   0   - success
   1   - error
   3   - no changes made
   
EOF
}

#------------------------------------------------------------------------------------

# command_exists
function command_exists { command -v "$1" >/dev/null 2>&1 ; }

#------------------------------------------------------------------------------------

# configure
function configure {
   if [ -z $DIRECTORY ]; then echo "dr configure requires directory argument.">&2 ; exit 1 ; fi
   mkdir -p "$DRETCDIR"   # ensure directrory exists.   
   echo "$DIRECTORY" > "${CFG_DIRECTORY}"
   
   # set up standard docker user and group for containers.
   groupadd -g 22022 "$DRGROUP"
   adduser --disabled-password --gecos '' -u 22022 --gid 22022 "$DRUSER"

   mkdir -p "$DIRECTORY"   # ensure directrory exists.
   chown -R "${DRUSER}:${DRGROUP}" "$DIRECTORY"
   
   echo "Configuration complete: created druser and set up $DIRECTORY." >&2
}

#------------------------------------------------------------------------------------

# checkimage 
function checkimage {
   # Check mandatory files in image (global var IMAGENAME) before touching host. Is it a valid dr container?
   for CFILE in "${REQDFILES[@]}"; do
      docker run --rm -it ${IMAGENAME} /bin/bash -c "command -v /dr/$CFILE >/dev/null 2>&1"
      if [ "$?" -ne 0 ]; then echo "${IMAGENAME} is not Docker Runner compatible. The script /dr/${CFILE} is missing.">&2 ; exit 1 ; fi
   done
   
   # Check running as druser.
   USERID=$(docker run --rm -it ${IMAGENAME} /bin/bash -c "id -u | tr -d '\r\n'")
   if [ "$USERID" != "22022" ]; then echo "${IMAGENAME} is not Docker Runner compatible. Not running as druser (uid 22022). It's >>$USERID<<">&2 ; exit 1 ; fi   
   
   echo "${IMAGENAME} is dr compatible.">&2
}

#------------------------------------------------------------------------------------

# createlaunchscript
function createlaunchscript {
   local SCRIPTPATH="/usr/local/bin/${SERVICENAME}"
   cat <<EOF >"$SCRIPTPATH"
#!/bin/bash
dr ${SERVICENAME} "\$@"
EOF
   chmod a+x "$SCRIPTPATH"
}

#------------------------------------------------------------------------------------

# initdrservice
function initdirservice {
   # can only call when service directory not present (for safety)
   if [ -d ${DIRSERVICE} ]; then
      echo "A service is already installed at ${DIRSERVICE}. Initialisation cancelled.">&2
      echo "You might want   dr update ${SERVICENAME}  instead.">&2
      exit 1
   fi

   # the directory that the container will update.
   local UPDATEDIR="${DIRSERVICE}/${DRBINDIR}"
   if [ -d "${UPDATEDIR}" ]; then
      rm -r "${UPDATEDIR}"
   fi
   mkdir -p "${UPDATEDIR}"
   chown -R "${DRUSER}:${DRGROUP}" "${UPDATEDIR}"
   
   # assumes docker image does not use entrypoint. Could instead override entrypoint maybe.
   docker run --rm -it -v "${UPDATEDIR}:/tempcopy" "${IMAGENAME}" /bin/bash -c "cp -a /dr/* /tempcopy/"                             
   if [ $? -ne 0 ]; then 
      echo "Failed to copy files.">&2 
      rm -r "${DIRSERVICE}"
      exit 1
   fi  

   # add standard dr config stuff.
   mkdir -p "${DIRSERVICE}/${DRCFGDIR}"
   echo "${IMAGENAME}" > "${DIRSERVICE}/${CFG_IMAGENAME}"
   echo "${SERVICENAME}" > "${DIRSERVICE}/${CFG_SERVICENAME}" 

   # Check mandatory files made it over to host okay from the container.
   for HFILE in "${REQDFILES[@]}"; do
      if [ ! -e "${DIRSERVICE}/${DRBINDIR}/${HFILE}" ]; then 
         echo "Install failed - ${HFILE} is required" 
         rm -r "${DIRSERVICE}"
         exit 1
      fi
   done
}

#------------------------------------------------------------------------------------

# install
function install {   
   if [ -z $IMAGENAME ]; then echo "dr install requires IMAGENAME.">&2 ; exit 1 ; fi
   if [ -z $SERVICENAME ]; then echo "dr install requires SERVICENAME.">&2 ; exit 1 ; fi

   checkimage
   
   local DNAME="dr-install"

   # --- all four globals have been set.
   initdirservice
   
   # create the standard config volume container.
   docker volume create --name="dr-${SERVICENAME}-config" >/dev/null
   # set permissions on config volume
   docker run --name="$DNAME" -v "dr-${SERVICENAME}-config:/config" "${COPYIMAGE}" /bin/bash -c "chown druser:drgroup /config && date >> /config/install_date"
   docker rm "$DNAME" >/dev/null 
    
   # Run the install script, e.g. to create volume containers.
   # todo: tidy up return/exit codes!         
   bash "${DIRSERVICE}/${DRBINDIR}/install" "${SERVICENAME}" "${IMAGENAME}"
   
   # allow direct execution of SERVICENAME without typing dr
   createlaunchscript
    
   # TODO: If we had errors then destroy everything!
   echo "Installation of service ${SERVICENAME} successful."
}

#------------------------------------------------------------------------------------

# destroy
function destroy {
   if [ -z $SERVICENAME ]; then die "dr destroy requires SERVICENAME to be set." ; fi
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi
   
   local RVALD=0

   # if the install process created a destroy script then run it, e.g. to destroy volume containers.
   # todo: tidy up return/exit codes!         
   if [ -e "${DIRSERVICE}/${DRBINDIR}/destroy" ]; then
      bash "${DIRSERVICE}/${DRBINDIR}/destroy" "${SERVICENAME}" "${IMAGENAME}"
   else 
      RVALD=1
   fi      
   
   # remove volume container.
   docker volume rm "dr-${SERVICENAME}-config" >/dev/null
   
   # remove launch script
   if [ -e "/usr/local/bin/${SERVICENAME}" ]; then rm "/usr/local/bin/${SERVICENAME}" ; fi
   
   # clean up service directory.
   rm -r "${DIRSERVICE}"
   
   exit $RVALD
}

#------------------------------------------------------------------------------------
# compress SOURCEFOLDER ARCHIVEFOLDER ARCHIVENAME [PASS]
function compress {
   local SOURCEFOLDER=$(realpath "$1" | tr -d '\r\n')
   if [ $? -ne 0 ]; then die "dr function compress: Couldn't find source path ${1}." ; fi
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   if [ $? -ne 0 ]; then die "dr function compress: Couldn't find destination path ${2}." ; fi
   local ARCHIVEPATH="$ARCHIVEFOLDER/$3"
   local PASSCMD=""
   if [ -n "$4" ]; then PASSCMD="-p${4}"; fi
   
   tar cf - -C "$SOURCEFOLDER" . | 7za a -si "${PASSCMD}" "$ARCHIVEPATH" > /dev/null
   if [ $? -ne 0 ]; then die "Failed to create archive of $SOURCEFOLDER" ; fi
}

# decompress DESTFOLDER ARCHIVEFOLDER ARCHIVENAME [PASS]
function decompress {
   local DESTFOLDER=$(realpath "$1" | tr -d '\r\n')
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   local ARCHIVEPATH="$ARCHIVEFOLDER/$3"

   if [ ! -e "$ARCHIVEPATH" ]; then die "dr function decompress: No such archive: $ARCHIVEPATH"; fi
   if [ ! -d "$DESTFOLDER" ]; then die "dr function decompress: Destination folder does not exist: $DESTFOLDER"; fi
   local PASSCMD=""
   if [ -n "$4" ]; then PASSCMD="-p${4}"; fi
   
   7za x -so "${PASSCMD}" "${ARCHIVEPATH}" | tar xf - -C "${DESTFOLDER}"
   if [ $? -ne 0 ]; then die "Failed to decompress archive $ARCHIVEPATH . The password may be incorrect!"; fi
}

# compressvolume VOLUMENAME ARCHIVEFOLDER ARCHIVENAME
function compressvolume {
   local VOLUMENAME="$1"
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   if [ $? -ne 0 ]; then die "dr function compressvolume: Couldn't find destination path $2." ; fi
   local ARCHIVENAME="$3"
   local DCNAME="dr-compressvolume"

   docker run --name="${DCNAME}" \
      -v "${VOLUMENAME}:/vol" -v "${ARCHIVEFOLDER}:/archive" "${COPYIMAGE}" \
      /bin/bash -c "tar zcf /archive/${ARCHIVENAME} -C /vol ."
   docker rm "${DCNAME}" >/dev/null 
}

# decompressvolume VOLUMENAME ARCHIVEFOLDER ARCHIVENAME
function decompressvolume {
   local VOLUMENAME="$1"
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   local ARCHIVENAME="$3"
   if [ ! -e "$ARCHIVEFOLDER/$ARCHIVENAME" ]; then die "dr function decompressvolume: Couldn't find archive $ARCHIVENAME" ; fi
   local DCNAME="dr-decompressvolume"

   # destroy any pre-existing data!
   docker volume rm "${VOLUMENAME}" >/dev/null
   docker volume create --name="${VOLUMENAME}" >/dev/null
   docker run --name="${DCNAME}" \
      -v "${VOLUMENAME}:/vol" -v "${ARCHIVEFOLDER}:/archive" "${COPYIMAGE}" \
      /bin/bash -c "tar zxf /archive/${ARCHIVENAME} -C /vol"
   docker rm "${DCNAME}" >/dev/null 
}

#------------------------------------------------------------------------------------

# backup BACKUPFILE
function backup {
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ -e "$BACKUPFILE" ]; then die "$BACKUPFILE already exists. Aborting." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   local TEMPPARENT="${TEMPROOT}/backup"
   local TEMPF="${TEMPPARENT}/drbackup"
   mkdir -p "$TEMPF"
   local TEMPC="${TEMPPARENT}/containerbackup"
   mkdir -p "$TEMPC"
   
   # for convenience, stick teh imagename in the tempparent folder
   echo "${IMAGENAME}" > "$TEMPPARENT/imagename.txt"
   
   # back up our configuration directory.
   compress "$DIRSERVICE/${DRCFGDIR}" "${TEMPF}" "${BACKUP_HOSTZIP}"
   
   # back up our volume container (dr-${SERVICENAME}-config).
   compressvolume "dr-${SERVICENAME}-config" "${TEMPF}" "${BACKUP_VOLZIP}"
   
   # call through to container to backup anything there in a subfolder.
   SCRIPTTORUN="${DIRSERVICE}/${DRBINDIR}/backup"
   bash "$SCRIPTTORUN" "$SERVICENAME" "$IMAGENAME" "$TEMPC"
      
   # Compress everything with password
   compress "$TEMPPARENT" "$TEMPROOT" "${BACKUP_MAIN}" "$PASS"
   mv "${TEMPROOT}/${BACKUP_MAIN}" "$BACKUPFILE"

   rm -r "${TEMPROOT}"   
   echo "Backed up to $BACKUPFILE succesfully.">&2
}

#------------------------------------------------------------------------------------

# restore BACKUPFILE
function restore {
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ ! -e "$BACKUPFILE" ]; then die "$BACKUPFILE doesn't exist. Aborting." ; fi
   if [ ! -e "$DIRSERVICE" ]; then die "$SERVICENAME exists - destroy it before restoring from backup." ; fi
   
   local TEMPROOT="$(mktemp -d)"
   local TEMPPARENT="${TEMPROOT}/backup"
   local TEMPF="${TEMPPARENT}/drbackup"
   mkdir -p "$TEMPF"
   local TEMPC="${TEMPPARENT}/containerbackup"
   mkdir -p "$TEMPC"
   
   # decompress the main backup
   cp "$BACKUPFILE" "${TEMPROOT}/${BACKUP_MAIN}"
   decompress "$TEMPPARENT" "$TEMPROOT" "$BACKUP_MAIN" "$PASS"
      
   # check backup has key files.
   local KEYFILES=("${TEMPF}/${BACKUP_HOSTZIP}" "${TEMPF}/${BACKUP_VOLZIP}" "${TEMPPARENT}/imagename.txt")
   for NEEDEDFILE in "${KEYFILES[@]}"; do
      if [ ! -e "$NEEDEDFILE" ]; then die "Backup corrupt. Missing ${NEEDEDFILE}."; fi
   done
   
   # set IMAGENAME - the only missing global var.
   IMAGENAME=$(<"$TEMPPARENT/imagename.txt")

   # now can install base service
   install
        
   # restore our volume container (dr-${SERVICENAME}-config), first destroying the one install just created.
   decompressvolume "dr-${SERVICENAME}-config" "${TEMPF}" "${BACKUP_VOLZIP}"

   # restore our configuration, first removing the one install just created.
   rm -r "${DIRSERVICE}/${DRCFGDIR}"
   decompress "${DIRSERVICE}/${DRCFGDIR}" "${TEMPF}" "${BACKUP_HOSTZIP}"
   
   # call through to container to restore anything there.
   SCRIPTTORUN="${DIRSERVICE}/${DRBINDIR}/restore"
   bash "$SCRIPTTORUN" "$SERVICENAME" "$IMAGENAME" "$TEMPC"
   
   echo "Service ${SERVICENAME} has been restored successfully."
}

#------------------------------------------------------------------------------------


# retriveDIRECTORY
function retrieveDIRECTORY {
   DIRERR="Run   dr configure DIRECTORY   before any other commands."
   if [ ! -d "$DRETCDIR" ]; then die "$DIRERR"; fi
   DIRECTORY=$(<"${CFG_DIRECTORY}")
   if [ -z "$DIRECTORY" ]; then die "$DIRERR"; fi
   if [ ! -d "$DIRECTORY" ]; then die "$DIRERR"; fi
}

#------------------------------------------------------------------------------------

# setglobals
function setglobals {
   # expects SERVICENAME to be set.
   if [ -z "$SERVICENAME" ]; then die "setglobals requires SERVICENAME to be set first." ; fi
   retrieveDIRECTORY

   DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi

   if [ ! -e "${DIRSERVICE}/${CFG_IMAGENAME}" ]; then die "Error - ${CFG_IMAGENAME} doesn't exist."; fi
   IMAGENAME=$(<"${DIRSERVICE}/${CFG_IMAGENAME}")
   if [ -z "$IMAGENAME" ]; then die "Error - ${CFG_IMAGENAME} is empty." ; fi
}

#------------------------------------------------------------------------------------


if ! command_exists docker ; then
   echo "Please install Docker before using Docker Runner.">&2
   echo "(e.g. use  https://github.com/j842/scripts/blob/master/install_docker.sh )">&2
   exit 1
fi
if [ "$(uname -rv | grep -c Debian)" -eq 0 ]; then
   echo "This script is currently only for Debian hosts.">&2
   exit 1
fi
# Check basic commands are available
COMMANDS=(gpg wget md5sum 7z 7za)
for NEEDEDCMD in "${COMMANDS[@]}"; do
  if ! command_exists "${NEEDEDCMD}" ; then 
      echo "Docker Runner requires ${NEEDEDCMD} to be available for scripts." >&2 
      echo "After Docker is installed, install all other dependencies with: ">&2 
      echo "apt-get install -y gnupg 7zip-full">&2 
      exit 1 
  fi
done

CMD="$1" ; shift

case "$CMD" in
   configure)
      DIRECTORY="$1"
      configure
      ;;
  
   "")
      showusage
      if [ -d "$DRETCDIR" ]; then retrieveDIRECTORY ; showservices ; fi
      exit 0
      ;;

   clean)
      # not including -v /etc:/etc since we aren't using exclude files.
      docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc
      ;;
          
   install)
      IMAGENAME="$1"
      SERVICENAME="$2"
      retrieveDIRECTORY
      DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
      install
      ;;
      
   update)
      SERVICENAME="$1"
      setglobals
      copydrfiles
      ;;
      
   # dr backup SERVICENAME BACKUPFILE
   backup)
      SERVICENAME="$1"
      setglobals
      backup "$2"
      ;;
     
   # dr restore SERVICENAME BACKUPFILE
   restore)
      SERVICENAME="$1"
      retrieveDIRECTORY
      DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
      restore "$2"
      ;;
      
   list)
      retrieveDIRECTORY
      showservices
      ;;
      
   #--------------------------         
      
   destroy)
      SERVICENAME="$1" ; shift
      setglobals
      destroy 
      ;;
      
   
   *)
      # check if CMD matches a service. If so run the appropriate script.
      # format:   dr SERVICENAME COMMAND ARGS
      SERVICENAME="$CMD"
      setglobals
      
      SUBCOMMAND="$1" ; shift
      SCRIPTTORUN="${DIRSERVICE}/${DRBINDIR}/${SUBCOMMAND}"
      if [ -n "$SUBCOMMAND" ] && [ -e "${SCRIPTTORUN}" ]; then
         bash "${SCRIPTTORUN}" "${SERVICENAME}" "${IMAGENAME}" "$@"
      else
         bash "${DIRSERVICE}/${DRBINDIR}/help" "${SERVICENAME}" "${IMAGENAME}"
      fi
      ;;
esac


